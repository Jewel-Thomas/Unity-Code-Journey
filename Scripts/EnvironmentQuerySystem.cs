// Unity Design Pattern Example: EnvironmentQuerySystem
// This script demonstrates the EnvironmentQuerySystem pattern in Unity
// Generated automatically - ready to use in your Unity project

The Environment Query System (EQS) is a powerful design pattern, often used in AI, to find the "best" place or object in an environment based on a set of criteria. It decouples the AI's decision-making from the environment's specific layout by defining flexible queries.

**Core Principles of EQS:**

1.  **Query Definition:** A blueprint of what to look for, composed of Generators, Filters, and Scorers.
2.  **Context:** The current state of the entity performing the query (e.g., the AI agent's position, the enemy's position).
3.  **Generators:** Create a set of potential "options" (e.g., points, objects) in the environment.
4.  **Filters:** Remove options that don't meet certain binary criteria (e.g., "is on ground?", "is not obstructed?").
5.  **Scorers:** Assign a numerical score to each remaining option based on how well it fits various continuous criteria (e.g., "distance to player", "amount of cover").
6.  **Selection:** Choose the option with the highest (or lowest) score.

This Unity example demonstrates an AI agent looking for the "best cover position" from a known target. It heavily leverages `ScriptableObject`s for query definitions, generators, filters, and scorers, making the system highly modular, reusable, and data-driven.

---

### **EnvironmentQuerySystem.cs**

This single file contains all the necessary components: interfaces, base classes for ScriptableObjects, concrete implementations, the static query executor, and an example `MonoBehaviour` for an AI agent using the system.

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq; // Used for ordering results, could be avoided for simpler cases

// =============================================================================================
// 1. CORE INTERFACES & DATA STRUCTURES
//    These define the common types used throughout the EQS.
// =============================================================================================

/// <summary>
/// Interface for the context of an Environment Query.
/// The context provides reference points and data for generators, filters, and scorers.
/// Each AI agent type might have its own context implementation.
/// </summary>
public interface IEnvironmentQueryContext
{
    /// <summary>
    /// The transform of the agent initiating the query.
    /// </summary>
    Transform AgentTransform { get; }

    /// <summary>
    /// The transform of the primary target (e.g., enemy, objective).
    /// </summary>
    Transform TargetTransform { get; }

    // Add other context-specific properties as needed, e.g.,
    // Vector3 LastKnownEnemyPosition { get; }
    // float AgentSpeed { get; }
}

/// <summary>
/// Represents a single potential option generated by the EQS.
/// It typically holds a position and a score. More data can be added as needed.
/// </summary>
public struct EnvironmentQueryOption
{
    public Vector3 Position;
    public float Score;

    public EnvironmentQueryOption(Vector3 position, float score = 0f)
    {
        Position = position;
        Score = score;
    }
}

// =============================================================================================
// 2. SCRIPTABLE OBJECT BASE CLASSES
//    These abstract classes define the blueprint for Generators, Filters, and Scorers
//    as ScriptableObjects, allowing them to be created as assets in Unity and reused.
// =============================================================================================

/// <summary>
/// Base class for all Environment Query Generators.
/// Generators are responsible for creating initial candidate points (options) in the environment.
/// </summary>
public abstract class EnvironmentQueryGeneratorSO : ScriptableObject
{
    [Tooltip("The LayerMask to use for physics checks (e.g., ground checks).")]
    [SerializeField] protected LayerMask _groundLayer;

    [Tooltip("Debug color for gizmos related to this generator.")]
    [SerializeField] protected Color _debugColor = Color.white;

    /// <summary>
    /// Generates a list of potential query options based on the context.
    /// </summary>
    /// <param name="context">The query context (e.g., agent's position, target's position).</param>
    /// <returns>A list of generated options.</returns>
    public abstract List<EnvironmentQueryOption> GenerateOptions(IEnvironmentQueryContext context);

    /// <summary>
    /// Draws debug gizmos for the generated options.
    /// </summary>
    /// <param name="options">The list of options to visualize.</param>
    public virtual void DrawGizmos(List<EnvironmentQueryOption> options)
    {
        Gizmos.color = _debugColor;
        foreach (var option in options)
        {
            Gizmos.DrawWireSphere(option.Position, 0.1f);
        }
    }
}

/// <summary>
/// Base class for all Environment Query Filters.
/// Filters remove options that do not meet specific criteria. They are binary (pass/fail).
/// Filters typically run before scorers to reduce the number of options needing expensive scoring.
/// </summary>
public abstract class EnvironmentQueryFilterSO : ScriptableObject
{
    [Tooltip("The LayerMask to use for physics checks within this filter.")]
    [SerializeField] protected LayerMask _obstacleLayer;

    [Tooltip("Debug color for gizmos related to this filter.")]
    [SerializeField] protected Color _debugColor = Color.yellow;

    /// <summary>
    /// Filters a list of options, returning only those that pass the criteria.
    /// </summary>
    /// <param name="options">The initial list of options.</param>
    /// <param name="context">The query context.</param>
    /// <returns>A filtered list of options.</returns>
    public abstract List<EnvironmentQueryOption> FilterOptions(List<EnvironmentQueryOption> options, IEnvironmentQueryContext context);

    /// <summary>
    /// Draws debug gizmos for the filtered options (e.g., showing which ones were removed).
    /// </summary>
    /// <param name="originalOptions">The original list of options before filtering.</param>
    /// <param name="filteredOptions">The options that passed the filter.</param>
    public virtual void DrawGizmos(List<EnvironmentQueryOption> originalOptions, List<EnvironmentQueryOption> filteredOptions)
    {
        // Default: Draw rejected options in red.
        Gizmos.color = Color.red;
        foreach (var option in originalOptions)
        {
            if (!filteredOptions.Any(f => f.Position == option.Position)) // Simple position check
            {
                Gizmos.DrawCube(option.Position, Vector3.one * 0.2f);
            }
        }
    }
}

/// <summary>
/// Base class for all Environment Query Scorers.
/// Scorers assign a numerical value to each option based on how well it meets certain criteria.
/// The highest (or lowest) scoring option is typically chosen.
/// </summary>
public abstract class EnvironmentQueryScorerSO : ScriptableObject
{
    [Tooltip("The weight applied to this scorer's contribution to the total score.")]
    [SerializeField] private float _scoreWeight = 1f;

    [Tooltip("Debug color for gizmos related to this scorer.")]
    [SerializeField] protected Color _debugColor = Color.cyan;

    public float ScoreWeight => _scoreWeight;

    /// <summary>
    /// Evaluates and assigns a score to a single option based on the context.
    /// </summary>
    /// <param name="option">The option to score.</param>
    /// <param name="context">The query context.</param>
    /// <returns>The calculated score for the option.</returns>
    public abstract float ScoreOption(EnvironmentQueryOption option, IEnvironmentQueryContext context);

    /// <summary>
    /// Draws debug gizmos related to this scorer's evaluation.
    /// </summary>
    /// <param name="options">The list of options with their assigned scores.</param>
    public virtual void DrawGizmos(List<EnvironmentQueryOption> options)
    {
        // Default: Visualize scores using sphere size/color if desired
    }
}

// =============================================================================================
// 3. CONCRETE SCRIPTABLE OBJECT IMPLEMENTATIONS (Examples)
//    These are specific implementations of Generators, Filters, and Scorers.
//    You'll create assets from these in your Unity project.
// =============================================================================================

// --- Generators ---

/// <summary>
/// Generator: Creates points in a spherical pattern around a reference point (AgentTransform).
/// </summary>
[CreateAssetMenu(fileName = "SpherePointsGenerator", menuName = "EQS/Generators/Sphere Points")]
public class SpherePointsGeneratorSO : EnvironmentQueryGeneratorSO
{
    [Tooltip("Radius of the sphere to generate points within.")]
    [SerializeField] private float _radius = 5f;
    [Tooltip("Number of points to generate.")]
    [SerializeField] private int _numberOfPoints = 20;
    [Tooltip("Offset above the agent's transform to start generating points from.")]
    [SerializeField] private Vector3 _offsetFromAgent = Vector3.up * 0.5f;

    public override List<EnvironmentQueryOption> GenerateOptions(IEnvironmentQueryContext context)
    {
        List<EnvironmentQueryOption> options = new List<EnvironmentQueryOption>();
        Vector3 center = context.AgentTransform.position + _offsetFromAgent;

        for (int i = 0; i < _numberOfPoints; i++)
        {
            // Generate a random point in a sphere.
            Vector3 randomPointInSphere = Random.insideUnitSphere * _radius;
            Vector3 potentialPoint = center + randomPointInSphere;

            // Simple ground projection: Raycast down to find ground.
            if (Physics.Raycast(potentialPoint + Vector3.up * 5f, Vector3.down, out RaycastHit hit, Mathf.Infinity, _groundLayer))
            {
                options.Add(new EnvironmentQueryOption(hit.point));
            }
            else // If no ground found, add the point as is (might be air or outside scene)
            {
                options.Add(new EnvironmentQueryOption(potentialPoint));
            }
        }
        return options;
    }

    public override void DrawGizmos(List<EnvironmentQueryOption> options)
    {
        base.DrawGizmos(options);
        if (options == null || options.Count == 0) return;

        // Draw the sphere bounds for the generator
        Gizmos.color = _debugColor;
        if (AIAgentEQSUser.LastQueryContext != null)
        {
            Vector3 center = AIAgentEQSUser.LastQueryContext.AgentTransform.position + _offsetFromAgent;
            Gizmos.DrawWireSphere(center, _radius);
        }
    }
}

// --- Filters ---

/// <summary>
/// Filter: Removes options that are obstructed by obstacles between the option and the agent's transform.
/// Useful for ensuring the agent can path to the chosen point.
/// </summary>
[CreateAssetMenu(fileName = "ObstructionFilter", menuName = "EQS/Filters/Obstruction Filter")]
public class ObstructionFilterSO : EnvironmentQueryFilterSO
{
    [Tooltip("Radius of the sphere to cast for obstruction. Should be roughly agent's radius.")]
    [SerializeField] private float _agentRadius = 0.5f;
    [Tooltip("Offset from the option position to raycast from (e.g., slightly above ground).")]
    [SerializeField] private Vector3 _offsetFromOption = Vector3.up * 0.5f;

    public override List<EnvironmentQueryOption> FilterOptions(List<EnvironmentQueryOption> options, IEnvironmentQueryContext context)
    {
        List<EnvironmentQueryOption> filteredOptions = new List<EnvironmentQueryOption>();
        Vector3 agentPosition = context.AgentTransform.position;

        foreach (var option in options)
        {
            Vector3 startPoint = option.Position + _offsetFromOption;
            Vector3 endPoint = agentPosition + _offsetFromOption; // To check path to agent
            Vector3 direction = (endPoint - startPoint).normalized;
            float distance = Vector3.Distance(startPoint, endPoint);

            // Use SphereCast to check for obstructions, considering agent's size
            if (!Physics.SphereCast(startPoint, _agentRadius, direction, out RaycastHit hit, distance, _obstacleLayer))
            {
                filteredOptions.Add(option);
            }
            // else: option is obstructed, so it's filtered out.
        }
        return filteredOptions;
    }
}

/// <summary>
/// Filter: Removes options that are not considered 'on ground' or walkable.
/// This could be extended with NavMesh checks.
/// </summary>
[CreateAssetMenu(fileName = "GroundFilter", menuName = "EQS/Filters/Ground Filter")]
public class GroundFilterSO : EnvironmentQueryFilterSO
{
    [Tooltip("Max distance from the option's Y to detect ground below.")]
    [SerializeField] private float _maxGroundDistance = 1f;
    [Tooltip("Offset from the option position to raycast from (e.g., slightly above ground).")]
    [SerializeField] private Vector3 _raycastOffset = Vector3.up * 0.1f;
    [Tooltip("The LayerMask for ground detection.")]
    [SerializeField] private LayerMask _groundLayer;

    public override List<EnvironmentQueryOption> FilterOptions(List<EnvironmentQueryOption> options, IEnvironmentQueryContext context)
    {
        List<EnvironmentQueryOption> filteredOptions = new List<EnvironmentQueryOption>();

        foreach (var option in options)
        {
            // Raycast down from slightly above the option to ensure it's on ground
            if (Physics.Raycast(option.Position + _raycastOffset, Vector3.down, out RaycastHit hit, _maxGroundDistance + _raycastOffset.y, _groundLayer))
            {
                filteredOptions.Add(option);
            }
        }
        return filteredOptions;
    }

    public override void DrawGizmos(List<EnvironmentQueryOption> originalOptions, List<EnvironmentQueryOption> filteredOptions)
    {
        // Base implementation draws rejected points in red.
        base.DrawGizmos(originalOptions, filteredOptions);
        Gizmos.color = _debugColor;
        foreach (var option in filteredOptions)
        {
            Gizmos.DrawWireCube(option.Position, Vector3.one * 0.2f); // Draw accepted points with a box
        }
    }
}


// --- Scorers ---

/// <summary>
/// Scorer: Scores options based on their distance to the target transform.
/// Closer points get a higher score (or lower, depending on 'invert').
/// </summary>
[CreateAssetMenu(fileName = "DistanceToTargetScorer", menuName = "EQS/Scorers/Distance To Target Scorer")]
public class DistanceToTargetScorerSO : EnvironmentQueryScorerSO
{
    [Tooltip("If true, closer points get a higher score. If false, further points get a higher score.")]
    [SerializeField] private bool _scoreCloserIsBetter = true;
    [Tooltip("Maximum distance for normalization. Distances beyond this are capped.")]
    [SerializeField] private float _maxDistance = 20f;

    public override float ScoreOption(EnvironmentQueryOption option, IEnvironmentQueryContext context)
    {
        if (context.TargetTransform == null) return 0f;

        float distance = Vector3.Distance(option.Position, context.TargetTransform.position);
        float normalizedDistance = Mathf.Clamp01(distance / _maxDistance);

        if (_scoreCloserIsBetter)
        {
            return (1f - normalizedDistance) * ScoreWeight; // Invert for closer = better
        }
        else
        {
            return normalizedDistance * ScoreWeight; // Further = better
        }
    }

    public override void DrawGizmos(List<EnvironmentQueryOption> options)
    {
        base.DrawGizmos(options);
        if (AIAgentEQSUser.LastQueryContext == null || AIAgentEQSUser.LastQueryContext.TargetTransform == null) return;
        Gizmos.color = _debugColor;
        Gizmos.DrawLine(AIAgentEQSUser.LastQueryContext.TargetTransform.position, AIAgentEQSUser.LastQueryContext.TargetTransform.position + Vector3.up); // Mark target
    }
}

/// <summary>
/// Scorer: Scores options based on how well they provide cover from the target.
/// Uses a Raycast to check for obstructions between the option and the target.
/// More obstructions = higher score.
/// </summary>
[CreateAssetMenu(fileName = "CoverFromTargetScorer", menuName = "EQS/Scorers/Cover From Target Scorer")]
public class CoverFromTargetScorerSO : EnvironmentQueryScorerSO
{
    [Tooltip("Offset from the option position to check cover from (e.g., slightly above ground).")]
    [SerializeField] private Vector3 _offsetFromOption = Vector3.up * 1f;
    [Tooltip("Offset from the target position to check cover against (e.g., target's head height).")]
    [SerializeField] private Vector3 _offsetFromTarget = Vector3.up * 1.5f;
    [Tooltip("LayerMask for obstacles that provide cover.")]
    [SerializeField] private LayerMask _coverLayer;
    [Tooltip("Maximum distance to consider for cover calculation.")]
    [SerializeField] private float _maxCoverDistance = 30f;

    public override float ScoreOption(EnvironmentQueryOption option, IEnvironmentQueryContext context)
    {
        if (context.TargetTransform == null) return 0f;

        Vector3 optionEyeLevel = option.Position + _offsetFromOption;
        Vector3 targetEyeLevel = context.TargetTransform.position + _offsetFromTarget;

        Vector3 directionToTarget = (targetEyeLevel - optionEyeLevel).normalized;
        float distanceToTarget = Vector3.Distance(optionEyeLevel, targetEyeLevel);

        if (distanceToTarget > _maxCoverDistance) return 0f; // Too far to care about cover

        // Check if there's an obstacle between the option and the target
        if (Physics.Raycast(optionEyeLevel, directionToTarget, out RaycastHit hit, distanceToTarget, _coverLayer))
        {
            // The closer the hit to the option, the better the cover.
            // A simple approach: return a fixed score, or score based on hit distance.
            // For simplicity, let's say *any* hit means good cover.
            return ScoreWeight;
        }
        return 0f; // No cover
    }

    public override void DrawGizmos(List<EnvironmentQueryOption> options)
    {
        base.DrawGizmos(options);
        if (options == null || options.Count == 0 || AIAgentEQSUser.LastQueryContext == null || AIAgentEQSUser.LastQueryContext.TargetTransform == null) return;

        Vector3 targetEyeLevel = AIAgentEQSUser.LastQueryContext.TargetTransform.position + _offsetFromTarget;
        Gizmos.color = Color.magenta;
        Gizmos.DrawSphere(targetEyeLevel, 0.1f); // Mark target eye level
        Gizmos.color = _debugColor;

        // Optionally draw raycasts for the top scoring options
        var bestOption = options.OrderByDescending(o => o.Score).FirstOrDefault();
        if (bestOption.Position != Vector3.zero) // Check if valid
        {
            Vector3 optionEyeLevel = bestOption.Position + _offsetFromOption;
            Debug.DrawLine(optionEyeLevel, targetEyeLevel, Color.yellow, 0.1f);
        }
    }
}


// =============================================================================================
// 4. ENVIRONMENT QUERY DEFINITION
//    This ScriptableObject ties together Generators, Filters, and Scorers to form a complete query.
// =============================================================================================

/// <summary>
/// A ScriptableObject that defines a complete Environment Query.
/// It orchestrates the Generators, Filters, and Scorers to find the best option.
/// </summary>
[CreateAssetMenu(fileName = "NewEnvironmentQuery", menuName = "EQS/Environment Query Definition")]
public class EnvironmentQueryDefinitionSO : ScriptableObject
{
    [Tooltip("The generator(s) responsible for creating the initial set of options.")]
    [SerializeField] private List<EnvironmentQueryGeneratorSO> _generators;

    [Tooltip("The filter(s) that remove options not meeting specific criteria. Run before scorers.")]
    [SerializeField] private List<EnvironmentQueryFilterSO> _filters;

    [Tooltip("The scorer(s) that evaluate and assign a score to each remaining option.")]
    [SerializeField] private List<EnvironmentQueryScorerSO> _scorers;

    public List<EnvironmentQueryOption> ExecuteQuery(IEnvironmentQueryContext context)
    {
        List<EnvironmentQueryOption> options = new List<EnvironmentQueryOption>();

        // 1. Generate Options
        foreach (var generator in _generators)
        {
            options.AddRange(generator.GenerateOptions(context));
        }

        if (options.Count == 0)
        {
            // Debug.LogWarning($"EQS: No options generated by query '{name}'.");
            return options;
        }

        // 2. Filter Options
        List<EnvironmentQueryOption> filteredOptions = new List<EnvironmentQueryOption>(options);
        foreach (var filter in _filters)
        {
            filteredOptions = filter.FilterOptions(filteredOptions, context);
            if (filteredOptions.Count == 0)
            {
                // Debug.LogWarning($"EQS: All options filtered out by filter '{filter.name}' in query '{name}'.");
                return filteredOptions;
            }
        }

        // 3. Score Options
        foreach (var option in filteredOptions)
        {
            float totalScore = 0f;
            foreach (var scorer in _scorers)
            {
                totalScore += scorer.ScoreOption(option, context);
            }
            // Update the score of the option in the list
            int index = filteredOptions.IndexOf(option); // Find by reference/value copy
            if (index != -1) // Should always be found
            {
                EnvironmentQueryOption scoredOption = filteredOptions[index];
                scoredOption.Score = totalScore;
                filteredOptions[index] = scoredOption; // Assign back the modified struct
            }
        }

        // Return the options, optionally sorted by score
        return filteredOptions.OrderByDescending(o => o.Score).ToList();
    }

    /// <summary>
    /// Draws gizmos for all components of the query.
    /// </summary>
    public void DrawGizmos(List<EnvironmentQueryOption> generatedOptions, List<EnvironmentQueryOption> filteredOptions, List<EnvironmentQueryOption> scoredOptions, EnvironmentQueryOption bestOption)
    {
        // Draw Generator Gizmos (initial options)
        foreach (var generator in _generators)
        {
            generator.DrawGizmos(generatedOptions);
        }

        // Draw Filter Gizmos (rejected options)
        List<EnvironmentQueryOption> currentFilteredOptions = new List<EnvironmentQueryOption>(generatedOptions);
        foreach (var filter in _filters)
        {
            List<EnvironmentQueryOption> nextFilteredOptions = filter.FilterOptions(currentFilteredOptions, AIAgentEQSUser.LastQueryContext);
            filter.DrawGizmos(currentFilteredOptions, nextFilteredOptions);
            currentFilteredOptions = nextFilteredOptions;
        }


        // Draw Scorer Gizmos (scored options)
        foreach (var scorer in _scorers)
        {
            scorer.DrawGizmos(scoredOptions);
        }

        // Draw best option
        if (bestOption.Position != Vector3.zero)
        {
            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(bestOption.Position, 0.5f);
            Gizmos.DrawLine(bestOption.Position, bestOption.Position + Vector3.up * 2f);
            Debug.DrawRay(bestOption.Position + Vector3.up * 2.1f, Vector3.up * 0.5f, Color.green);
        }
    }
}


// =============================================================================================
// 5. CONCRETE QUERY CONTEXT IMPLEMENTATION (for the AI Agent)
// =============================================================================================

/// <summary>
/// Specific implementation of IEnvironmentQueryContext for an AI Agent.
/// </summary>
public class AIAgentQueryContext : IEnvironmentQueryContext
{
    public Transform AgentTransform { get; private set; }
    public Transform TargetTransform { get; private set; }

    public AIAgentQueryContext(Transform agent, Transform target)
    {
        AgentTransform = agent;
        TargetTransform = target;
    }
}

// =============================================================================================
// 6. EXAMPLE MONOBEHAVIOUR FOR AI AGENT USAGE
//    This script would be attached to an AI agent to use the EQS.
// =============================================================================================

/// <summary>
/// Example MonoBehaviour for an AI Agent that uses the Environment Query System.
/// This script demonstrates how an agent would trigger a query and process the results.
/// </summary>
public class AIAgentEQSUser : MonoBehaviour
{
    [Header("EQS Setup")]
    [Tooltip("The Environment Query Definition ScriptableObject to execute.")]
    [SerializeField] private EnvironmentQueryDefinitionSO _queryDefinition;

    [Tooltip("The target transform the AI agent is interested in (e.g., the player).")]
    [SerializeField] private Transform _targetTransform;

    [Tooltip("Interval (in seconds) at which to run the EQS query.")]
    [SerializeField] private float _queryInterval = 1f;

    [Header("Debug Visualization")]
    [Tooltip("Whether to draw debug gizmos for the query.")]
    [SerializeField] private bool _drawDebugGizmos = true;
    [Tooltip("Show all generated options.")]
    [SerializeField] private bool _showGeneratedOptions = true;
    [Tooltip("Show all filtered options.")]
    [SerializeField] private bool _showFilteredOptions = true;
    [Tooltip("Show all scored options.")]
    [SerializeField] private bool _showScoredOptions = true;

    private IEnvironmentQueryContext _queryContext;
    private List<EnvironmentQueryOption> _lastQueryResults = new List<EnvironmentQueryOption>();
    private EnvironmentQueryOption _bestOption;
    private float _nextQueryTime;

    // Static context for gizmo drawing in ScriptableObjects (hacky, but common for debug)
    public static IEnvironmentQueryContext LastQueryContext { get; private set; }

    private void Start()
    {
        if (_queryDefinition == null)
        {
            Debug.LogError("EQS: Query Definition is not assigned!", this);
            enabled = false;
            return;
        }
        if (_targetTransform == null)
        {
            Debug.LogWarning("EQS: Target Transform is not assigned. Query results may be limited.", this);
        }

        _queryContext = new AIAgentQueryContext(this.transform, _targetTransform);
        _nextQueryTime = Time.time;
    }

    private void Update()
    {
        if (Time.time >= _nextQueryTime)
        {
            ExecuteEnvironmentQuery();
            _nextQueryTime = Time.time + _queryInterval;
        }

        // Example AI behavior: If a best option is found, move towards it (simplified)
        if (_bestOption.Position != Vector3.zero)
        {
            // For a real AI, you'd use a NavMeshAgent or other pathfinding here.
            // transform.position = Vector3.MoveTowards(transform.position, _bestOption.Position, Time.deltaTime * 2f);
            // Debug.DrawLine(transform.position, _bestOption.Position, Color.gray);
        }
    }

    /// <summary>
    /// Executes the defined Environment Query and stores the results.
    /// </summary>
    private void ExecuteEnvironmentQuery()
    {
        _lastQueryResults = _queryDefinition.ExecuteQuery(_queryContext);

        if (_lastQueryResults.Count > 0)
        {
            _bestOption = _lastQueryResults.OrderByDescending(o => o.Score).First();
            // Debug.Log($"EQS: Best option found at {_bestOption.Position} with score {_bestOption.Score}");

            // In a real game, the AI would now act on this best option:
            // - Move to _bestOption.Position
            // - Change state (e.g., from patrolling to taking cover)
            // - Perform an action at that position
        }
        else
        {
            _bestOption = new EnvironmentQueryOption(Vector3.zero); // Reset if no options
            Debug.LogWarning("EQS: No valid options found for the query.");
        }
    }

    private void OnDrawGizmos()
    {
        if (!_drawDebugGizmos || _queryDefinition == null || _queryContext == null) return;

        LastQueryContext = _queryContext; // Update static context for ScriptableObject gizmos

        List<EnvironmentQueryOption> generatedOptions = new List<EnvironmentQueryOption>();
        foreach (var generator in _queryDefinition.GetType().GetField("_generators", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance).GetValue(_queryDefinition) as List<EnvironmentQueryGeneratorSO>)
        {
            if (generator != null)
            {
                generatedOptions.AddRange(generator.GenerateOptions(_queryContext));
            }
        }

        List<EnvironmentQueryOption> filteredOptions = new List<EnvironmentQueryOption>(generatedOptions);
        foreach (var filter in _queryDefinition.GetType().GetField("_filters", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance).GetValue(_queryDefinition) as List<EnvironmentQueryFilterSO>)
        {
            if (filter != null)
            {
                filteredOptions = filter.FilterOptions(filteredOptions, _queryContext);
            }
        }
        
        List<EnvironmentQueryOption> scoredOptions = new List<EnvironmentQueryOption>(filteredOptions); // Create a copy for scoring
        for (int i = 0; i < scoredOptions.Count; i++)
        {
            EnvironmentQueryOption option = scoredOptions[i];
            float totalScore = 0f;
            foreach (var scorer in _queryDefinition.GetType().GetField("_scorers", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance).GetValue(_queryDefinition) as List<EnvironmentQueryScorerSO>)
            {
                if (scorer != null)
                {
                    totalScore += scorer.ScoreOption(option, _queryContext);
                }
            }
            option.Score = totalScore;
            scoredOptions[i] = option; // Update struct in list
        }


        _queryDefinition.DrawGizmos(
            _showGeneratedOptions ? generatedOptions : new List<EnvironmentQueryOption>(),
            _showFilteredOptions ? filteredOptions : new List<EnvironmentQueryOption>(),
            _showScoredOptions ? scoredOptions : new List<EnvironmentQueryOption>(),
            _bestOption
        );

        if (_targetTransform != null)
        {
            Gizmos.color = Color.red;
            Gizmos.DrawSphere(_targetTransform.position, 0.3f);
            Gizmos.DrawLine(_targetTransform.position, _targetTransform.position + Vector3.up * 1.5f);
        }
    }
}
```

---

### How to Use This in Unity:

**1. Create Layers:**

*   Go to `Edit -> Project Settings -> Tags and Layers`.
*   Add the following layers (if they don't exist):
    *   `Ground`
    *   `Obstacle`
    *   `Cover`

**2. Prepare your Scene:**

*   **Create an AI Agent:** Create an empty GameObject (e.g., `AI_Agent`). Add the `AIAgentEQSUser` component to it.
*   **Create a Target:** Create another empty GameObject (e.g., `Player_Target`). Position it somewhere in the scene. Drag this GameObject to the `Target Transform` field of your `AI_Agent`'s `AIAgentEQSUser` component.
*   **Create Environment Geometry:**
    *   Add a `Plane` or several `Cube`s to act as `Ground`. Assign them to the `Ground` layer.
    *   Add some `Cube`s or other 3D objects to act as `Obstacles` and `Cover`. Assign them to both the `Obstacle` and `Cover` layers. Make sure they are tall enough to block line of sight.

**3. Create ScriptableObject Assets:**

*   In your Project window, right-click -> `Create -> EQS`. You will see options for:
    *   `Environment Query Definition`
    *   `Generators/Sphere Points`
    *   `Filters/Obstruction Filter`
    *   `Filters/Ground Filter`
    *   `Scorers/Distance To Target Scorer`
    *   `Scorers/Cover From Target Scorer`

*   **Create one of each:**
    *   `SpherePointsGenerator` (e.g., `MySphereGen`)
    *   `ObstructionFilter` (e.g., `MyObstructionFilter`)
    *   `GroundFilter` (e.g., `MyGroundFilter`)
    *   `DistanceToTargetScorer` (e.g., `MyDistToTargetScorer`)
    *   `CoverFromTargetScorer` (e.g., `MyCoverScorer`)
    *   `Environment Query Definition` (e.g., `FindCoverQuery`)

**4. Configure ScriptableObject Assets:**

*   **`MySphereGen` (SpherePointsGenerator):**
    *   `Radius`: 10-15 (depends on your scene scale)
    *   `Number Of Points`: 50-100
    *   `Ground Layer`: Select `Ground`
    *   `Debug Color`: Choose a distinct color like Blue.
*   **`MyGroundFilter` (GroundFilter):**
    *   `Max Ground Distance`: 1
    *   `Ground Layer`: Select `Ground`
    *   `Debug Color`: Choose Yellow.
*   **`MyObstructionFilter` (ObstructionFilter):**
    *   `Agent Radius`: 0.5 (or approximate agent's size)
    *   `Obstacle Layer`: Select `Obstacle`
    *   `Debug Color`: Choose Orange.
*   **`MyDistToTargetScorer` (DistanceToTargetScorer):**
    *   `Score Closer Is Better`: Check this (we want to get somewhat close to the target, not infinitely far)
    *   `Max Distance`: 20
    *   `Score Weight`: 0.5 (adjust to balance with cover score)
    *   `Debug Color`: Choose Magenta.
*   **`MyCoverScorer` (CoverFromTargetScorer):**
    *   `Offset From Option`: Vector3.up * 1
    *   `Offset From Target`: Vector3.up * 1.5
    *   `Cover Layer`: Select `Cover`
    *   `Max Cover Distance`: 30
    *   `Score Weight`: 1.0 (cover is important for this query)
    *   `Debug Color`: Choose Cyan.

**5. Assemble the Query Definition (`FindCoverQuery`):**

*   Select your `FindCoverQuery` asset.
*   **Generators:** Drag `MySphereGen` into the list.
*   **Filters:** Drag `MyGroundFilter` and `MyObstructionFilter` into the list. (Order matters for filters, typically cheapest first).
*   **Scorers:** Drag `MyDistToTargetScorer` and `MyCoverScorer` into the list.

**6. Assign Query to AI Agent:**

*   Select your `AI_Agent` GameObject.
*   Drag your `FindCoverQuery` asset to the `Query Definition` field in the `AIAgentEQSUser` component.
*   Ensure `_targetTransform` is set to your `Player_Target` GameObject.
*   Adjust `Query Interval` and `Debug Visualization` options as desired.

**7. Run the Scene:**

*   Enter Play Mode.
*   Observe the `AI_Agent` in the Scene view. You should see gizmos:
    *   Blue spheres (Generated Options)
    *   Red cubes (Options filtered out by Ground/Obstruction)
    *   Yellow/Orange boxes (Options that passed filters)
    *   Green sphere and line (The best chosen option, which provides cover and is reasonably close).
    *   Magenta line/sphere around target (from scorers).

Move the `AI_Agent` or `Player_Target` around, and the `AI_Agent` should re-evaluate and find new cover points.

---

### **Explanation of the Pattern in this Example:**

*   **`EnvironmentQueryDefinitionSO`:** This is the core `Query`. It's a `ScriptableObject` that defines *what* constitutes a "find cover" query by referencing specific `Generator`, `Filter`, and `Scorer` assets.
*   **`IEnvironmentQueryContext` / `AIAgentQueryContext`:** This provides the necessary runtime data (agent's position, target's position) for the query to evaluate options relative to the current situation.
*   **`EnvironmentQueryGeneratorSO` (e.g., `SpherePointsGeneratorSO`):** The `GenerateOptions` method creates the initial pool of potential cover points in a sphere around the agent.
*   **`EnvironmentQueryFilterSO` (e.g., `GroundFilterSO`, `ObstructionFilterSO`):**
    *   `GroundFilter` removes points that are in the air or off-level.
    *   `ObstructionFilter` ensures the AI agent can actually reach the point without hitting an immediate obstacle.
    *   These filters reduce the number of options before scoring, improving performance by avoiding expensive calculations on invalid points.
*   **`EnvironmentQueryScorerSO` (e.g., `DistanceToTargetScorerSO`, `CoverFromTargetScorerSO`):**
    *   `DistanceToTargetScorer` scores points based on how close they are to the target (with a preference for "closer" or "further" configurable).
    *   `CoverFromTargetScorer` performs raycasts to check if a point is obstructed from the target's view, giving higher scores to points with good cover.
    *   Each scorer contributes to a total score, weighted by its `ScoreWeight`.
*   **`AIAgentEQSUser`:** This `MonoBehaviour` acts as the AI's "brain" that initiates the query. It sets up the `Context` and calls `ExecuteQuery` on the `EnvironmentQueryDefinitionSO` asset. It then receives the sorted `EnvironmentQueryOption` list and uses the `_bestOption` for decision-making (e.g., moving to that position).

This design provides a highly flexible and reusable system. You can easily create new generators (e.g., "points along a wall", "points near health packs"), filters (e.g., "is visible to player", "is not in hazardous zone"), and scorers (e.g., "has line of sight to target", "is near an ammo crate") without modifying the core EQS logic. You then combine these components into new `EnvironmentQueryDefinitionSO` assets to define entirely new behaviors for your AI.