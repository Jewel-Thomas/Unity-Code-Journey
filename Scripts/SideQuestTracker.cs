// Unity Design Pattern Example: SideQuestTracker
// This script demonstrates the SideQuestTracker pattern in Unity
// Generated automatically - ready to use in your Unity project

This example demonstrates the 'SideQuestTracker' design pattern in Unity. This pattern centralizes the management of all in-game side quests, providing a clear API for other game systems (NPCs, collectibles, UI) to interact with quest states and progress, while notifying interested parties about changes.

It leverages:
1.  **ScriptableObjects** for defining static quest data (reusable assets).
2.  A **Singleton MonoBehaviour** (`SideQuestTracker`) to manage runtime quest instances.
3.  **C# Events** for broadcasting quest state and progress changes, enabling loose coupling.
4.  **Serializable runtime classes** to hold mutable quest data.

## SideQuestTracker Pattern: Complete Unity Example

To use this example:

1.  **Create a C# Script:** Create a new C# script in your Unity project, name it `SideQuestSystem` (or any name you prefer), and copy-paste all the code below into it.
2.  **Import TextMeshPro:** If you don't have TextMeshPro imported, Unity will prompt you to do so when you add `TextMeshProUGUI` to a UI element.
3.  **Setup the Scene:**
    *   **Game Manager:** Create an empty GameObject in your scene (e.g., `_GameManager`). Add the `SideQuestTracker` component to it.
    *   **Quest Definitions:** Create some `ScriptableObject` assets for your quests:
        *   In your Project window, right-click -> `Create` -> `SideQuestSystem` -> `SideQuestDefinition`.
        *   Create a few (e.g., "Collect 3 Berries", "Talk to Villager", "Defeat Goblins"). Fill in their `questName`, `questDescription`, and `requiredProgressAmount`. **Crucially, ensure their `questID` is unique (a GUID is generated by default, which is good).**
    *   **Initial Quests (Optional):** Drag some of your created `SideQuestDefinition` assets into the `Initial Quest Definitions` list on the `SideQuestTracker` component in the Inspector. These quests will be initialized when the game starts.
    *   **Player:** Create a simple Player object (e.g., a Capsule with a `CharacterController` and a `Collider` set to `Is Trigger`). **Make sure your Player GameObject has the tag "Player"**.
    *   **Quest Giver:** Create an NPC (e.g., a Cube). Add a `SphereCollider` to it, check `Is Trigger`, and adjust its radius. Add the `QuestGiver` component to it. Assign one of your `SideQuestDefinition` assets to its `Quest To Give` field.
    *   **Quest Objectives:** Create some collectible items (e.g., small Spheres or Capsules) for the "Collect X" type quest. Add a `SphereCollider` to each, check `Is Trigger`, and adjust its radius. Add the `QuestObjectiveTrigger` component to each. Assign the *same* `SideQuestDefinition` to all collectibles that belong to that quest.
    *   **UI Logger:**
        *   Create a UI Canvas (`GameObject` -> `UI` -> `Canvas`).
        *   Inside the Canvas, create a `TextMeshPro - Text` element (`GameObject` -> `UI` -> `TextMeshPro - Text`). Adjust its size and position.
        *   Create an empty GameObject under the Canvas (e.g., `QuestLogger`). Add the `QuestLoggerUI` component to it. Drag your `TextMeshPro - Text` element into the `Quest Log Text` field of the `QuestLoggerUI` component in the Inspector.

Now, run the scene. Interact with the Quest Giver to start a quest, collect items to advance it, and observe the UI logger updating in real-time.

---

```csharp
using UnityEngine;
using System.Collections.Generic;
using System; // For Action delegate
using System.Text; // For StringBuilder in UI example
using TMPro; // For TextMeshProUGUI in UI example

// --- 1. QuestState Enum ---
/// <summary>
/// Defines the possible states a side quest can be in.
/// </summary>
public enum QuestState
{
    /// <summary>Quest has been defined but not yet offered or started.</summary>
    NotStarted,
    /// <summary>Quest has been accepted by the player and is currently in progress.</summary>
    Active,
    /// <summary>Quest objectives have been met and rewards are given or pending.</summary>
    Completed,
    /// <summary>Quest conditions were not met, or a negative outcome occurred.</summary>
    Failed
}

// --- 2. SideQuestDefinition ScriptableObject ---
/// <summary>
/// A ScriptableObject that defines the static data for a side quest.
/// Designers can create these assets in the Unity Editor.
/// </summary>
[CreateAssetMenu(fileName = "NewSideQuest", menuName = "SideQuestSystem/SideQuestDefinition")]
public class SideQuestDefinition : ScriptableObject
{
    // A unique identifier for the quest. Using GUID ensures global uniqueness.
    // Designers can override it, but it should remain unique.
    public string questID = System.Guid.NewGuid().ToString();
    public string questName = "New Quest";
    [TextArea(3, 10)]
    public string questDescription = "A brief description of the quest objective.";
    public int requiredProgressAmount = 1; // e.g., collect 5 items, kill 3 enemies. For "Talk to NPC" quests, this might be 1.

    // --- Optional Additions for a more complex system ---
    // public ItemData[] rewards; // Reference to ScriptableObjects defining rewards
    // public string[] prerequisiteQuestIDs; // Quests that must be completed/active before this one
    // public SideQuestDefinition[] followUpQuests; // Quests that become available after this one
    // public Sprite questIcon; // Icon for UI
}

// --- 3. SideQuest Runtime Class ---
/// <summary>
/// Represents a single instance of a side quest at runtime.
/// Holds the current, mutable state and progress of a quest,
/// referencing its static definition.
/// </summary>
[System.Serializable] // Make it serializable if you plan to save/load quest data
public class SideQuest
{
    /// <summary>The static definition of this quest.</summary>
    public SideQuestDefinition Definition { get; private set; }
    /// <summary>The current state of this quest (NotStarted, Active, etc.).</summary>
    public QuestState CurrentState { get; private set; }
    /// <summary>The current progress towards completing the quest's objectives.</summary>
    public int CurrentProgress { get; private set; }

    /// <summary>
    /// Initializes a new runtime quest instance from a QuestDefinition.
    /// </summary>
    /// <param name="definition">The static data defining this quest.</param>
    public SideQuest(SideQuestDefinition definition)
    {
        Definition = definition;
        CurrentProgress = 0;
        CurrentState = QuestState.NotStarted;
    }

    /// <summary>
    /// Sets the state of the quest.
    /// </summary>
    /// <param name="newState">The new state for the quest.</param>
    public void SetState(QuestState newState)
    {
        CurrentState = newState;
    }

    /// <summary>
    /// Advances the progress of the quest by a specified amount,
    /// capping it at the required progress amount.
    /// </summary>
    /// <param name="amount">The amount to add to the current progress. Defaults to 1.</param>
    public void AdvanceProgress(int amount = 1)
    {
        CurrentProgress = Mathf.Min(CurrentProgress + amount, Definition.requiredProgressAmount);
    }

    /// <summary>
    /// Calculates the completion percentage of the quest.
    /// </summary>
    /// <returns>A float representing the progress, from 0.0 to 1.0.</returns>
    public float GetProgressPercentage()
    {
        if (Definition.requiredProgressAmount == 0) return 1f; // Handle quests with 0 required progress as "always complete" or specific logic
        return (float)CurrentProgress / Definition.requiredProgressAmount;
    }
}

// --- 4. SideQuestTracker Singleton MonoBehaviour ---
/// <summary>
/// The central manager for all side quests in the game.
/// Implements the Singleton pattern to provide easy access from any script.
/// It tracks quest states, manages progress, and notifies other systems via events.
/// </summary>
public class SideQuestTracker : MonoBehaviour
{
    // --- Singleton Implementation ---
    /// <summary>Static instance of the SideQuestTracker, ensuring only one exists.</summary>
    public static SideQuestTracker Instance { get; private set; }

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            // If another instance already exists, destroy this one.
            Debug.LogWarning("SideQuestTracker: Duplicate instance found, destroying this one.");
            Destroy(gameObject);
            return;
        }
        Instance = this;
        // Optionally, keep the tracker alive across scene loads.
        // Remove this if you want quest states to reset per scene.
        DontDestroyOnLoad(gameObject);
        Debug.Log("SideQuestTracker: Initialized.");
    }

    // --- Quest Storage ---
    /// <summary>A dictionary to store all active and available quests, keyed by their unique ID.</summary>
    private Dictionary<string, SideQuest> _quests = new Dictionary<string, SideQuest>();

    // --- Events for Notifying Other Systems ---
    /// <summary>Event invoked when any quest's state changes (e.g., NotStarted -> Active).</summary>
    public event Action<string, QuestState> OnQuestStateChanged;
    /// <summary>Event invoked when a quest's progress changes.</summary>
    /// <remarks>Parameters: questID, currentProgress, requiredProgress</remarks>
    public event Action<string, int, int> OnQuestProgressChanged;
    /// <summary>Event invoked specifically when a quest transitions to the Completed state.</summary>
    public event Action<string> OnQuestCompleted;
    /// <summary>Event invoked specifically when a quest transitions to the Failed state.</summary>
    public event Action<string> OnQuestFailed;

    // --- Public API for Managing Quests ---

    /// <summary>
    /// Initializes a new side quest using its definition. This adds the quest to the tracker
    /// in the 'NotStarted' state. It's often called when the game starts or when a quest
    /// becomes available for the first time.
    /// </summary>
    /// <param name="questDefinition">The ScriptableObject defining the quest.</param>
    /// <returns>True if the quest was successfully initialized, false if it already exists.</returns>
    public bool InitializeQuest(SideQuestDefinition questDefinition)
    {
        if (_quests.ContainsKey(questDefinition.questID))
        {
            // Quest already known, no need to re-initialize.
            // This can happen if quests are initialized from multiple sources (e.g., initial list + save file).
            // Debug.LogWarning($"SideQuestTracker: Quest with ID '{questDefinition.questID}' already exists.");
            return false;
        }

        SideQuest newQuest = new SideQuest(questDefinition);
        _quests.Add(questDefinition.questID, newQuest);
        Debug.Log($"SideQuestTracker: Initialized quest '{questDefinition.questName}' ({questDefinition.questID}). State: {newQuest.CurrentState}");
        OnQuestStateChanged?.Invoke(questDefinition.questID, QuestState.NotStarted);
        return true;
    }

    /// <summary>
    /// Starts an initialized quest, setting its state to 'Active'. This is typically
    /// called when the player accepts a quest from an NPC.
    /// </summary>
    /// <param name="questID">The unique ID of the quest to start.</param>
    /// <returns>True if the quest was successfully started, false otherwise (e.g., not found, already active).</returns>
    public bool StartQuest(string questID)
    {
        if (!_quests.TryGetValue(questID, out SideQuest quest))
        {
            Debug.LogWarning($"SideQuestTracker: Cannot start quest '{questID}'. Quest not found.");
            return false;
        }

        if (quest.CurrentState == QuestState.NotStarted)
        {
            quest.SetState(QuestState.Active);
            Debug.Log($"SideQuestTracker: Started quest '{quest.Definition.questName}' ({questID}).");
            OnQuestStateChanged?.Invoke(questID, QuestState.Active);
            // Notify subscribers of initial progress (0/Required) when a quest starts.
            OnQuestProgressChanged?.Invoke(questID, quest.CurrentProgress, quest.Definition.requiredProgressAmount);
            return true;
        }
        else
        {
            Debug.Log($"SideQuestTracker: Cannot start quest '{questID}'. Current state is {quest.CurrentState}.");
            return false;
        }
    }

    /// <summary>
    /// Advances the progress of an active quest. If the progress meets or exceeds
    /// the required amount, the quest is automatically completed. This is called
    /// when the player performs a quest objective (e.g., collects an item, defeats an enemy).
    /// </summary>
    /// <param name="questID">The unique ID of the quest to advance.</param>
    /// <param name="amount">The amount by which to advance the progress. Defaults to 1.</param>
    /// <returns>True if progress was advanced, false otherwise (e.g., quest not found, not active).</returns>
    public bool AdvanceQuest(string questID, int amount = 1)
    {
        if (!_quests.TryGetValue(questID, out SideQuest quest))
        {
            Debug.LogWarning($"SideQuestTracker: Cannot advance quest '{questID}'. Quest not found.");
            return false;
        }

        if (quest.CurrentState == QuestState.Active)
        {
            int oldProgress = quest.CurrentProgress;
            quest.AdvanceProgress(amount);

            if (quest.CurrentProgress != oldProgress) // Only notify if progress actually changed
            {
                Debug.Log($"SideQuestTracker: Advanced progress for '{quest.Definition.questName}' ({questID}). Progress: {quest.CurrentProgress}/{quest.Definition.requiredProgressAmount}");
                OnQuestProgressChanged?.Invoke(questID, quest.CurrentProgress, quest.Definition.requiredProgressAmount);
            }

            if (quest.CurrentProgress >= quest.Definition.requiredProgressAmount)
            {
                // If progress is met, automatically complete the quest.
                CompleteQuest(questID);
            }
            return true;
        }
        else
        {
            Debug.Log($"SideQuestTracker: Cannot advance quest '{questID}'. Quest is not active (current state: {quest.CurrentState}).");
            return false;
        }
    }

    /// <summary>
    /// Manually completes a quest. This can be used for quests completed via dialogue choices,
    /// or when a quest has a "return to NPC" step and the player interacts with them.
    /// It ensures the progress is maxed out and sets the state to 'Completed'.
    /// </summary>
    /// <param name="questID">The unique ID of the quest to complete.</param>
    /// <returns>True if the quest was successfully completed, false otherwise.</returns>
    public bool CompleteQuest(string questID)
    {
        if (!_quests.TryGetValue(questID, out SideQuest quest))
        {
            Debug.LogWarning($"SideQuestTracker: Cannot complete quest '{questID}'. Quest not found.");
            return false;
        }

        if (quest.CurrentState != QuestState.Completed && quest.CurrentState != QuestState.Failed)
        {
            quest.SetState(QuestState.Completed);
            // Ensure progress is fully met even if `AdvanceQuest` wasn't called enough times.
            quest.AdvanceProgress(quest.Definition.requiredProgressAmount - quest.CurrentProgress);
            Debug.Log($"SideQuestTracker: Completed quest '{quest.Definition.questName}' ({questID}).");
            OnQuestStateChanged?.Invoke(questID, QuestState.Completed);
            OnQuestProgressChanged?.Invoke(questID, quest.CurrentProgress, quest.Definition.requiredProgressAmount); // Final progress update
            OnQuestCompleted?.Invoke(questID); // Specific completion event
            return true;
        }
        else
        {
            Debug.Log($"SideQuestTracker: Cannot complete quest '{questID}'. Quest is already {quest.CurrentState}.");
            return false;
        }
    }

    /// <summary>
    /// Fails a quest, setting its state to 'Failed'. This can happen due to time limits,
    /// specific player choices, or failure conditions.
    /// </summary>
    /// <param name="questID">The unique ID of the quest to fail.</param>
    /// <returns>True if the quest was successfully failed, false otherwise.</returns>
    public bool FailQuest(string questID)
    {
        if (!_quests.TryGetValue(questID, out SideQuest quest))
        {
            Debug.LogWarning($"SideQuestTracker: Cannot fail quest '{questID}'. Quest not found.");
            return false;
        }

        if (quest.CurrentState != QuestState.Completed && quest.CurrentState != QuestState.Failed)
        {
            quest.SetState(QuestState.Failed);
            Debug.Log($"SideQuestTracker: Failed quest '{quest.Definition.questName}' ({questID}).");
            OnQuestStateChanged?.Invoke(questID, QuestState.Failed);
            OnQuestFailed?.Invoke(questID); // Specific failure event
            return true;
        }
        else
        {
            Debug.Log($"SideQuestTracker: Cannot fail quest '{questID}'. Quest is already {quest.CurrentState}.");
            return false;
        }
    }

    /// <summary>
    /// Retrieves a SideQuest object by its ID.
    /// </summary>
    /// <param name="questID">The unique ID of the quest.</param>
    /// <returns>The SideQuest object if found, otherwise null.</returns>
    public SideQuest GetQuest(string questID)
    {
        _quests.TryGetValue(questID, out SideQuest quest);
        return quest;
    }

    /// <summary>
    /// Checks if a quest with the given ID is currently active.
    /// </summary>
    /// <param name="questID">The unique ID of the quest.</param>
    /// <returns>True if the quest exists and is active, false otherwise.</returns>
    public bool IsQuestActive(string questID)
    {
        SideQuest quest = GetQuest(questID);
        return quest != null && quest.CurrentState == QuestState.Active;
    }

    /// <summary>
    /// Checks if a quest with the given ID is completed.
    /// </summary>
    /// <param name="questID">The unique ID of the quest.</param>
    /// <returns>True if the quest exists and is completed, false otherwise.</returns>
    public bool IsQuestCompleted(string questID)
    {
        SideQuest quest = GetQuest(questID);
        return quest != null && quest.CurrentState == QuestState.Completed;
    }

    /// <summary>
    /// Gets a read-only list of all currently tracked quests.
    /// Useful for UI systems that need to display all available/active quests.
    /// </summary>
    /// <returns>A new List containing all tracked SideQuest objects.</returns>
    public IReadOnlyList<SideQuest> GetAllQuests()
    {
        return new List<SideQuest>(_quests.Values);
    }

    // --- Initial Quest Population (Example) ---
    [Header("Initial Quests (Optional)")]
    [SerializeField]
    [Tooltip("Quest definitions to be initialized when the game starts.")]
    private List<SideQuestDefinition> _initialQuestDefinitions = new List<SideQuestDefinition>();

    private void Start()
    {
        // On game start, initialize any quests pre-defined in the inspector.
        // In a real game, this might also involve loading quests from a save file,
        // or dynamically initializing based on game progression.
        foreach (var def in _initialQuestDefinitions)
        {
            InitializeQuest(def);
        }
    }

    // --- Persistence Integration (Conceptual Example) ---
    // A full persistence system is beyond the scope of this example,
    // but here's how you'd conceptually integrate it.

    /// <summary>
    /// Conceptual method for saving current quest states.
    /// </summary>
    public List<QuestSaveData> GetQuestSaveData()
    {
        List<QuestSaveData> saveData = new List<QuestSaveData>();
        foreach (var quest in _quests.Values)
        {
            saveData.Add(new QuestSaveData
            {
                QuestID = quest.Definition.questID,
                State = quest.CurrentState,
                Progress = quest.CurrentProgress
            });
        }
        Debug.Log("Quest data prepared for saving.");
        return saveData;
    }

    /// <summary>
    /// Conceptual method for loading and applying saved quest states.
    /// This would typically be called after game startup, using data retrieved from a save file.
    /// </summary>
    /// <param name="loadedData">A list of saved quest data.</param>
    /// <param name="allQuestDefinitions">A list of ALL possible quest definitions in the game (e.g., from Resources.LoadAll, AssetDatabase, or a master list).</param>
    public void LoadQuestData(List<QuestSaveData> loadedData, List<SideQuestDefinition> allQuestDefinitions)
    {
        _quests.Clear(); // Clear current quests before loading new ones

        Dictionary<string, SideQuestDefinition> definitionLookup = new Dictionary<string, SideQuestDefinition>();
        foreach (var def in allQuestDefinitions)
        {
            definitionLookup[def.questID] = def;
        }

        foreach (var data in loadedData)
        {
            if (definitionLookup.TryGetValue(data.QuestID, out SideQuestDefinition definition))
            {
                SideQuest quest = new SideQuest(definition);
                quest.SetState(data.State);
                // Ensure progress is set correctly, but also respecting max progress.
                // AdvanceProgress handles the capping.
                if (data.Progress > 0)
                {
                    quest.AdvanceProgress(data.Progress);
                }
                _quests.Add(quest.Definition.questID, quest);
                Debug.Log($"Loaded quest '{definition.questName}' with state {data.State} and progress {data.Progress}");
                OnQuestStateChanged?.Invoke(quest.Definition.questID, quest.CurrentState);
                OnQuestProgressChanged?.Invoke(quest.Definition.questID, quest.CurrentProgress, quest.Definition.requiredProgressAmount);
            }
            else
            {
                Debug.LogWarning($"SideQuestTracker: Could not find definition for quest ID '{data.QuestID}' during load. Skipping.");
            }
        }
        Debug.Log($"SideQuestTracker: Loaded {loadedData.Count} quests.");
    }
}

/// <summary>
/// A simple serializable class to store quest data for saving and loading.
/// </summary>
[System.Serializable]
public class QuestSaveData
{
    public string QuestID;
    public QuestState State;
    public int Progress;
}


// --- 5. Example Usage Components ---

// --- QuestGiver Example ---
/// <summary>
/// An example component for an NPC that can offer and start quests.
/// Interacting with this object will attempt to start the associated quest.
/// </summary>
public class QuestGiver : MonoBehaviour
{
    [SerializeField] private SideQuestDefinition _questToGive;
    [SerializeField] private KeyCode _interactionKey = KeyCode.E;
    [SerializeField] private float _interactionRange = 3f;

    private bool _playerInRange = false;

    private void Update()
    {
        // Simple range check (for demonstration, a trigger collider is often better)
        if (SideQuestTracker.Instance == null) return;

        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _interactionRange);
        _playerInRange = false;
        foreach (var hitCollider in hitColliders)
        {
            if (hitCollider.CompareTag("Player"))
            {
                _playerInRange = true;
                break;
            }
        }

        if (_playerInRange && Input.GetKeyDown(_interactionKey))
        {
            Interact();
        }
    }

    private void Interact()
    {
        if (SideQuestTracker.Instance == null)
        {
            Debug.LogError("QuestGiver: SideQuestTracker not found! Make sure it's in the scene and active.");
            return;
        }

        if (_questToGive == null)
        {
            Debug.LogWarning($"{gameObject.name}: No quest definition assigned to QuestGiver. Cannot interact.");
            return;
        }

        SideQuest quest = SideQuestTracker.Instance.GetQuest(_questToGive.questID);

        if (quest == null)
        {
            Debug.LogWarning($"QuestGiver: Quest '{_questToGive.questID}' not found in tracker. Ensure it's in the initial quest list or initialized elsewhere.");
            return;
        }

        switch (quest.CurrentState)
        {
            case QuestState.NotStarted:
                Debug.Log($"QuestGiver: Player accepted '{_questToGive.questName}'. Starting quest!");
                SideQuestTracker.Instance.StartQuest(_questToGive.questID);
                break;
            case QuestState.Active:
                Debug.Log($"QuestGiver: Player already on '{_questToGive.questName}'. Progress: {quest.CurrentProgress}/{quest.Definition.requiredProgressAmount}.");
                // Here, you might offer different dialogue, or allow early completion if applicable.
                if (quest.CurrentProgress >= quest.Definition.requiredProgressAmount)
                {
                    Debug.Log($"QuestGiver: Player has completed objectives for '{_questToGive.questName}'. Completing quest!");
                    SideQuestTracker.Instance.CompleteQuest(_questToGive.questID);
                }
                break;
            case QuestState.Completed:
                Debug.Log($"QuestGiver: Player already completed '{_questToGive.questName}'. Good job! Time for rewards or new quests.");
                // Award items, start a new quest, trigger a cutscene, etc.
                break;
            case QuestState.Failed:
                Debug.Log($"QuestGiver: Player failed '{_questToGive.questName}'. Perhaps next time, adventurer.");
                // Offer to restart, or mourn the loss.
                break;
        }
    }

    // Visual helper for interaction range in editor
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(transform.position, _interactionRange);
    }
}

// --- QuestObjectiveTrigger Example ---
/// <summary>
/// An example component for an object in the world (e.g., collectible, enemy)
/// that, when interacted with or triggered, advances the progress of a specific quest.
/// </summary>
[RequireComponent(typeof(Collider))] // Ensure there's a collider for trigger events
public class QuestObjectiveTrigger : MonoBehaviour
{
    [SerializeField] private SideQuestDefinition _questToAdvance;
    [SerializeField] private int _progressAmount = 1;
    [SerializeField] private bool _destroyOnTrigger = true; // e.g., for collectibles that disappear

    private void Start()
    {
        // Ensure the collider is set to be a trigger
        Collider col = GetComponent<Collider>();
        if (col != null && !col.isTrigger)
        {
            col.isTrigger = true;
            Debug.LogWarning($"{gameObject.name}: Collider was not set to 'Is Trigger'. Setting it automatically.");
        }
        else if (col == null)
        {
            Debug.LogError($"{gameObject.name}: No Collider component found. QuestObjectiveTrigger requires a Collider.");
            enabled = false; // Disable script if no collider
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        // Check if the triggering object is the Player
        if (other.CompareTag("Player"))
        {
            if (SideQuestTracker.Instance == null)
            {
                Debug.LogError("QuestObjectiveTrigger: SideQuestTracker not found! Make sure it's in the scene and active.");
                return;
            }

            if (_questToAdvance == null)
            {
                Debug.LogWarning($"{gameObject.name}: No quest definition assigned to QuestObjectiveTrigger. Cannot advance quest.");
                return;
            }

            // Attempt to advance the quest through the tracker
            bool advanced = SideQuestTracker.Instance.AdvanceQuest(_questToAdvance.questID, _progressAmount);

            if (advanced)
            {
                Debug.Log($"QuestObjectiveTrigger: Player collected '{gameObject.name}', advanced quest '{_questToAdvance.questName}'.");
                if (_destroyOnTrigger)
                {
                    Destroy(gameObject); // Remove the objective from the scene
                }
            }
            else
            {
                // This might happen if the quest is not active, or doesn't exist.
                // Depending on game design, you might still destroy the object,
                // or have it persist until the quest becomes active.
                Debug.Log($"QuestObjectiveTrigger: Could not advance quest '{_questToAdvance.questName}'. Is it active? Current state: {SideQuestTracker.Instance.GetQuest(_questToAdvance.questID)?.CurrentState.ToString() ?? "N/A"}");
            }
        }
    }
}

// --- QuestLoggerUI Example ---
/// <summary>
/// A simple UI component that subscribes to QuestTracker events
/// and displays active quest information on a TextMeshProUGUI element.
/// </summary>
public class QuestLoggerUI : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI _questLogText;

    // Dictionary to hold display strings for active/available quests.
    private Dictionary<string, string> _questDisplayStrings = new Dictionary<string, string>();

    private void Start()
    {
        if (_questLogText == null)
        {
            Debug.LogError("QuestLoggerUI: TextMeshProUGUI component not assigned. Please assign it in the Inspector.");
            enabled = false; // Disable the script if no text component
            return;
        }

        if (SideQuestTracker.Instance == null)
        {
            Debug.LogError("QuestLoggerUI: SideQuestTracker not found! Cannot subscribe to events. Make sure it's in the scene and active.");
            enabled = false; // Disable the script if no tracker
            return;
        }

        // Subscribe to relevant quest events
        SideQuestTracker.Instance.OnQuestStateChanged += HandleQuestStateChanged;
        SideQuestTracker.Instance.OnQuestProgressChanged += HandleQuestProgressChanged;
        SideQuestTracker.Instance.OnQuestCompleted += HandleQuestCompletedOrFailed;
        SideQuestTracker.Instance.OnQuestFailed += HandleQuestCompletedOrFailed;

        // Populate initial display with any quests already known by the tracker
        foreach (var quest in SideQuestTracker.Instance.GetAllQuests())
        {
            AddOrUpdateQuestDisplayString(quest);
        }
        RefreshDisplay(); // Update the UI text initially
    }

    private void OnDestroy()
    {
        // Unsubscribe from events to prevent memory leaks when this object is destroyed
        if (SideQuestTracker.Instance != null)
        {
            SideQuestTracker.Instance.OnQuestStateChanged -= HandleQuestStateChanged;
            SideQuestTracker.Instance.OnQuestProgressChanged -= HandleQuestProgressChanged;
            SideQuestTracker.Instance.OnQuestCompleted -= HandleQuestCompletedOrFailed;
            SideQuestTracker.Instance.OnQuestFailed -= HandleQuestCompletedOrFailed;
        }
    }

    /// <summary>
    /// Event handler for when a quest's state changes.
    /// </summary>
    private void HandleQuestStateChanged(string questID, QuestState newState)
    {
        SideQuest quest = SideQuestTracker.Instance.GetQuest(questID);
        if (quest != null)
        {
            AddOrUpdateQuestDisplayString(quest);
            RefreshDisplay();
        }
    }

    /// <summary>
    /// Event handler for when a quest's progress changes.
    /// </summary>
    private void HandleQuestProgressChanged(string questID, int current, int required)
    {
        SideQuest quest = SideQuestTracker.Instance.GetQuest(questID);
        if (quest != null)
        {
            AddOrUpdateQuestDisplayString(quest);
            RefreshDisplay();
        }
    }

    /// <summary>
    /// Event handler for when a quest is completed or failed.
    /// </summary>
    private void HandleQuestCompletedOrFailed(string questID)
    {
        // For a simple logger, we remove completed/failed quests from the "active" display.
        // A full quest journal UI might move them to a different section.
        if (_questDisplayStrings.ContainsKey(questID))
        {
            _questDisplayStrings.Remove(questID);
            RefreshDisplay();
        }
    }

    /// <summary>
    /// Prepares or updates the string representation of a quest for display.
    /// </summary>
    private void AddOrUpdateQuestDisplayString(SideQuest quest)
    {
        string status = "";
        switch (quest.CurrentState)
        {
            case QuestState.NotStarted:
                status = "<color=grey>(Available)</color>";
                break;
            case QuestState.Active:
                status = $"<color=yellow>({quest.CurrentProgress}/{quest.Definition.requiredProgressAmount})</color>";
                break;
            case QuestState.Completed:
                status = "<color=green>(Completed!)</color>";
                break;
            case QuestState.Failed:
                status = "<color=red>(Failed!)</color>";
                break;
        }

        // Only display quests that are 'NotStarted' or 'Active' in the primary logger.
        // Completed/Failed quests are removed or moved to a separate journal.
        if (quest.CurrentState == QuestState.Active || quest.CurrentState == QuestState.NotStarted)
        {
            _questDisplayStrings[quest.Definition.questID] = $"<link=\"{quest.Definition.questID}\"><b>{quest.Definition.questName}</b></link>: {quest.Definition.questDescription} {status}";
        }
        else // For completed/failed, ensure they are not in the active display list
        {
            if (_questDisplayStrings.ContainsKey(quest.Definition.questID))
            {
                _questDisplayStrings.Remove(quest.Definition.questID);
            }
        }
    }

    /// <summary>
    /// Rebuilds and updates the TextMeshProUGUI element with the current quest log.
    /// </summary>
    private void RefreshDisplay()
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("<b>--- Active Quests ---</b>");

        if (_questDisplayStrings.Count == 0)
        {
            sb.AppendLine("<i>No active quests.</i>");
        }
        else
        {
            foreach (var entry in _questDisplayStrings.Values)
            {
                sb.AppendLine(entry);
            }
        }

        _questLogText.text = sb.ToString();
    }
}
```