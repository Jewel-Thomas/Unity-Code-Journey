// Unity Design Pattern Example: AIThreatSystem
// This script demonstrates the AIThreatSystem pattern in Unity
// Generated automatically - ready to use in your Unity project

This C# Unity script provides a complete and practical implementation of the **AI Threat System design pattern**. It allows multiple AI entities (Threat Targets) to track and prioritize threats from various sources (Threat Sources) like players or other NPCs. The system handles threat generation, decay, and efficient querying, making it suitable for real-world Unity games.

---

### AIThreatSystem.cs

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq; // Required for LINQ queries like OrderByDescending

// =====================================================================================
// AIThreatSystem Design Pattern Example for Unity
// =====================================================================================
// This script demonstrates the AI Threat System design pattern.
//
// Pattern Description:
// The AI Threat System is a centralized manager that tracks "threat" or "aggro"
// generated by various game entities (Threat Sources) against other entities (Threat Targets),
// typically AI-controlled characters. AI entities can then query this system to determine
// which Threat Source currently poses the highest threat, allowing them to prioritize
// targets for combat, healing, or other behaviors.
//
// Key Components:
// 1.  AIThreatSystem (this class): The central singleton manager.
//     -   Manages a map of all active threats.
//     -   Provides methods to add, reduce, or clear threat.
//     -   Handles the natural decay of threat over time.
//     -   Allows AI to query for their current highest threat source.
// 2.  ThreatSource (represented by a GameObject): An entity that generates threat
//     (e.g., Player, another AI performing an aggressive action, a healing spell).
// 3.  ThreatTarget (represented by a GameObject): An entity that receives threat
//     and needs to respond to it (e.g., an enemy AI deciding who to attack, an AI ally
//     deciding who to heal based on who is being attacked most).
// 4.  ThreatValue: A numeric value representing the current level of threat
//     a ThreatSource poses to a ThreatTarget.
// 5.  ThreatDecay: Threat values naturally decrease over time if no new threat
//     is generated, simulating an AI "forgetting" or losing interest if a source
//     is inactive.
//
// How it works:
// -   When a ThreatSource performs an action (e.g., player attacks an enemy), it
//     calls `AIThreatSystem.Instance.AddThreat(enemyGameObject, playerGameObject, amount)`.
// -   Periodically, the `AIThreatSystem` reduces all active threat values by a decay rate.
// -   AI entities (ThreatTargets) periodically call
//     `AIThreatSystem.Instance.GetHighestThreatSource(this.gameObject)` to find
//     who they should be focusing on.
//
// Benefits:
// -   **Decoupling:** Threat generation and threat response are separated from each other.
//     ThreatSources don't need to know how AIs respond; AIs don't need to know
//     the specifics of how threat is generated.
// -   **Centralized Management:** All threat data is in one place, making it easy
//     to inspect, debug, and modify.
// -   **Scalability:** Easily handle many sources and targets without complex
//     direct communication between them.
// -   **Dynamic Behavior:** AI behavior adapts dynamically to the changing threat landscape.
//
// =====================================================================================

/// <summary>
/// The central AI Threat System manager.
/// Implemented as a Singleton to provide easy access from any part of the game.
/// This MonoBehaviour should be placed on a persistent GameObject in your scene.
/// </summary>
public class AIThreatSystem : MonoBehaviour
{
    // --- Singleton Setup ---
    // Public static property to access the single instance of the AIThreatSystem.
    public static AIThreatSystem Instance { get; private set; }

    [Header("Threat System Settings")]
    [Tooltip("How much threat decays per second for each source against each target.")]
    [SerializeField]
    private float threatDecayRatePerSecond = 1.0f; 
    
    [Tooltip("Minimum threat value. Threats below this will be considered insignificant and removed.")]
    [SerializeField]
    private float minThreatThreshold = 0.1f; 

    // --- Internal Threat Data Structure ---
    // This nested dictionary stores all active threat relationships.
    // Outer Key:   The GameObject that is the 'Threat Target' (e.g., an enemy AI).
    // Inner Key:   The GameObject that is the 'Threat Source' (e.g., the Player, an ally AI).
    // Inner Value: The current threat level from the inner key (source) against the outer key (target).
    private Dictionary<GameObject, Dictionary<GameObject, float>> _threatMap = 
        new Dictionary<GameObject, Dictionary<GameObject, float>>();

    // --- Singleton Initialization ---
    private void Awake()
    {
        // Ensure only one instance of AIThreatSystem exists.
        if (Instance != null && Instance != this)
        {
            Debug.LogWarning("Multiple AIThreatSystem instances found. Destroying duplicate.");
            Destroy(gameObject); // Destroy this duplicate instance.
        }
        else
        {
            Instance = this; // Set this instance as the singleton.
            // Optional: Make the system persist across scene loads.
            // Remove if you want a new system instance per scene or manage scene transitions manually.
            DontDestroyOnLoad(gameObject); 
        }
    }

    // --- Threat Management Methods ---

    /// <summary>
    /// Adds or increases threat from a source against a target.
    /// This is the primary method Threat Sources will call.
    /// </summary>
    /// <param name="target">The GameObject that is being threatened (e.g., an enemy AI).</param>
    /// <param name="source">The GameObject that is generating the threat (e.g., the Player).</param>
    /// <param name="amount">The amount of threat to add. Must be positive.</param>
    public void AddThreat(GameObject target, GameObject source, float amount)
    {
        // Validate input parameters.
        if (target == null || source == null)
        {
            Debug.LogWarning("AIThreatSystem.AddThreat: Target or Source GameObject is null. Cannot add threat.");
            return;
        }
        if (amount <= 0)
        {
            Debug.LogWarning($"AIThreatSystem.AddThreat: Threat amount must be positive. Received {amount}.");
            return;
        }

        // Ensure the target exists in the main threat map.
        // If not, create a new inner dictionary for it.
        if (!_threatMap.ContainsKey(target))
        {
            _threatMap[target] = new Dictionary<GameObject, float>();
        }

        // Add or update the threat from the source against this target.
        if (_threatMap[target].ContainsKey(source))
        {
            _threatMap[target][source] += amount;
        }
        else
        {
            _threatMap[target].Add(source, amount);
        }
        // Example debug log:
        // Debug.Log($"Threat added: {source.name} -> {target.name}, Amount: {amount:F2}. New total: {_threatMap[target][source]:F2}");
    }

    /// <summary>
    /// Reduces threat from a source against a target.
    /// Threat will not go below the `minThreatThreshold`.
    /// </summary>
    /// <param name="target">The GameObject that is being threatened.</param>
    /// <param name="source">The GameObject that is generating the threat.</param>
    /// <param name="amount">The amount of threat to reduce. Must be positive.</param>
    public void ReduceThreat(GameObject target, GameObject source, float amount)
    {
        // Validate input parameters.
        if (target == null || source == null)
        {
            Debug.LogWarning("AIThreatSystem.ReduceThreat: Target or Source GameObject is null. Cannot reduce threat.");
            return;
        }
        if (amount <= 0)
        {
            Debug.LogWarning($"AIThreatSystem.ReduceThreat: Reduction amount must be positive. Received {amount}.");
            return;
        }

        // Check if the threat entry exists before attempting to modify it.
        if (_threatMap.ContainsKey(target) && _threatMap[target].ContainsKey(source))
        {
            _threatMap[target][source] -= amount;
            // If threat drops below the threshold, remove it entirely.
            if (_threatMap[target][source] <= minThreatThreshold)
            {
                _threatMap[target].Remove(source);
                // Debug.Log($"Threat removed: {source.name} -> {target.name}. Threat dropped below threshold.");
            }
        }
    }

    /// <summary>
    /// Removes all threat from a specific source against a specific target.
    /// </summary>
    /// <param name="target">The GameObject that is being threatened.</param>
    /// <param name="source">The GameObject that is generating the threat.</param>
    public void ClearThreat(GameObject target, GameObject source)
    {
        if (target == null || source == null) return;

        if (_threatMap.ContainsKey(target) && _threatMap[target].ContainsKey(source))
        {
            _threatMap[target].Remove(source);
            // Debug.Log($"Threat cleared: {source.name} -> {target.name}.");
        }
    }

    /// <summary>
    /// Clears all threats against a specific target.
    /// Call this when a target entity is destroyed, becomes inactive, or resets its threat state.
    /// </summary>
    /// <param name="target">The GameObject whose threats should be cleared.</param>
    public void ClearAllThreatsForTarget(GameObject target)
    {
        if (target == null) return;

        if (_threatMap.ContainsKey(target))
        {
            _threatMap.Remove(target);
            // Debug.Log($"All threats cleared for target: {target.name}.");
        }
    }

    /// <summary>
    /// Clears all threats generated by a specific source across all targets.
    /// Call this when a source entity is destroyed, becomes inactive, or becomes irrelevant.
    /// </summary>
    /// <param name="source">The GameObject whose threats should be cleared.</param>
    public void ClearAllThreatsFromSource(GameObject source)
    {
        if (source == null) return;

        // Iterate through all targets and remove the specified source's threat.
        foreach (var targetEntry in _threatMap)
        {
            if (targetEntry.Value.ContainsKey(source))
            {
                targetEntry.Value.Remove(source);
            }
        }
        // After removing source threats, clean up any target entries that are now empty.
        RemoveEmptyTargetEntries();
        // Debug.Log($"All threats cleared from source: {source.name}.");
    }
    
    /// <summary>
    /// Internal helper method to remove target entries from the main threat map
    /// if they no longer have any active sources threatening them, or if the target
    /// GameObject itself has been destroyed. This keeps the map clean and efficient.
    /// </summary>
    private void RemoveEmptyTargetEntries()
    {
        // Use a temporary list to store keys to remove to avoid modifying the collection while iterating.
        List<GameObject> targetsToRemove = new List<GameObject>();
        
        foreach (var targetEntry in _threatMap)
        {
            GameObject target = targetEntry.Key;
            var sourcesForTarget = targetEntry.Value;

            // First, clean up any sources within this target's map that might have been destroyed.
            List<GameObject> sourcesToRemove = new List<GameObject>();
            foreach (var sourceEntry in sourcesForTarget)
            {
                if (sourceEntry.Key == null) // Check if the source GameObject has been destroyed
                {
                    sourcesToRemove.Add(sourceEntry.Key);
                }
            }
            foreach (var source in sourcesToRemove)
            {
                sourcesForTarget.Remove(source);
            }

            // If the target GameObject itself is destroyed or it no longer has any active sources,
            // mark it for removal from the main threat map.
            if (target == null || sourcesForTarget.Count == 0)
            {
                targetsToRemove.Add(target);
            }
        }

        // Now, remove the marked target entries from the main threat map.
        foreach (var target in targetsToRemove)
        {
            _threatMap.Remove(target);
        }
    }

    /// <summary>
    /// Gets the current threat value from a source against a target.
    /// Returns 0 if no threat exists or if GameObjects are null.
    /// </summary>
    /// <param name="target">The GameObject that is being threatened.</param>
    /// <param name="source">The GameObject that is generating the threat.</param>
    /// <returns>The current threat value, or 0 if none.</returns>
    public float GetThreatValue(GameObject target, GameObject source)
    {
        if (target == null || source == null) return 0f;

        if (_threatMap.ContainsKey(target) && _threatMap[target].ContainsKey(source))
        {
            return _threatMap[target][source];
        }
        return 0f;
    }

    /// <summary>
    /// Queries the system for the GameObject that poses the highest threat to the given target.
    /// This is the primary method AI entities will use to decide who to focus on.
    /// </summary>
    /// <param name="target">The GameObject (e.g., an enemy AI) looking for its highest threat.</param>
    /// <returns>The GameObject of the highest threat source, or null if no active threats exist
    /// or all active threats are below the `minThreatThreshold`.</returns>
    public GameObject GetHighestThreatSource(GameObject target)
    {
        if (target == null) return null;

        if (_threatMap.ContainsKey(target) && _threatMap[target].Count > 0)
        {
            // Use LINQ to filter out null sources, ensure threat is above threshold,
            // then order by threat value in descending order and take the first (highest).
            var highestThreatEntry = _threatMap[target]
                                    .Where(entry => entry.Key != null && entry.Value > minThreatThreshold)
                                    .OrderByDescending(entry => entry.Value)
                                    .FirstOrDefault(); // Returns default (empty KeyValuePair) if no valid entries

            if (highestThreatEntry.Key != null) // Check if a valid entry was actually found
            {
                return highestThreatEntry.Key;
            }
        }
        return null; // No threat, target not in map, or all sources are invalid/below threshold
    }
    
    /// <summary>
    /// Gets the current threat level of the highest threat source for a given target.
    /// This is useful if the AI needs to know how significant the threat is (e.g., to decide to flee).
    /// </summary>
    /// <param name="target">The GameObject whose highest threat level is requested.</param>
    /// <returns>The threat value of the highest threat source, or 0 if no active threats exist.</returns>
    public float GetHighestThreatValue(GameObject target)
    {
        if (target == null) return 0f;

        if (_threatMap.ContainsKey(target) && _threatMap[target].Count > 0)
        {
            var highestThreatEntry = _threatMap[target]
                                    .Where(entry => entry.Key != null && entry.Value > minThreatThreshold)
                                    .OrderByDescending(entry => entry.Value)
                                    .FirstOrDefault();

            if (highestThreatEntry.Key != null)
            {
                return highestThreatEntry.Value;
            }
        }
        return 0f;
    }


    // --- Decay Logic ---
    private void Update()
    {
        // Apply threat decay to all active threats based on the time elapsed since the last frame.
        ApplyThreatDecay(Time.deltaTime);

        // Periodically clean up entries from the threat map.
        // This handles cases where GameObjects acting as targets or sources might have been
        // destroyed in the scene, or sub-dictionaries become empty due to decay.
        // Doing this every frame is generally fine for typical game scales, but for
        // extremely large numbers of threats, consider performing this less frequently (e.g., every 0.5 seconds).
        RemoveEmptyTargetEntries();
    }

    /// <summary>
    /// Applies decay to all active threats in the system based on elapsed time.
    /// </summary>
    private void ApplyThreatDecay(float deltaTime)
    {
        // Iterate through a copy of target keys to avoid errors if elements are removed during iteration.
        var targetsToProcess = new List<GameObject>(_threatMap.Keys);

        foreach (GameObject target in targetsToProcess)
        {
            // If the target GameObject itself has been destroyed, remove its entry and continue.
            if (target == null) 
            {
                _threatMap.Remove(target);
                continue;
            }

            var sourcesForTarget = _threatMap[target]; // Get the inner dictionary for this target.
            var sourcesToRemove = new List<GameObject>(); // List to hold sources that decay to zero or are destroyed.

            // Iterate through sources threatening this target.
            foreach (var entry in sourcesForTarget)
            {
                GameObject source = entry.Key;
                float currentThreat = entry.Value;

                // If the source GameObject has been destroyed, mark it for removal.
                if (source == null) 
                {
                    sourcesToRemove.Add(source);
                    continue;
                }

                // Apply decay.
                currentThreat -= threatDecayRatePerSecond * deltaTime;
                if (currentThreat <= minThreatThreshold)
                {
                    // If threat drops below threshold, mark it for removal.
                    sourcesToRemove.Add(source);
                }
                else
                {
                    // Otherwise, update the threat value.
                    sourcesForTarget[source] = currentThreat;
                }
            }

            // Remove any sources that were marked for removal (decayed or destroyed).
            foreach (GameObject source in sourcesToRemove)
            {
                sourcesForTarget.Remove(source);
            }

            // If, after decay and cleanup, a target no longer has any active threats, remove it
            // from the main threat map to keep it clean.
            if (sourcesForTarget.Count == 0)
            {
                _threatMap.Remove(target);
            }
        }
    }
    
    // --- Editor Debugging (Optional) ---
    // You can call this method from other scripts or a custom editor window to inspect
    // the current state of the threat system.
    public void LogCurrentThreats()
    {
        Debug.Log("--- Current AIThreatSystem State ---");
        if (_threatMap.Count == 0)
        {
            Debug.Log("No active threats.");
            return;
        }

        foreach (var targetEntry in _threatMap)
        {
            if (targetEntry.Key == null)
            {
                Debug.LogWarning("  Target: NULL (threats will be cleaned up).");
                continue;
            }

            Debug.Log($"Target: <color=red>{targetEntry.Key.name}</color>");
            if (targetEntry.Value.Count == 0)
            {
                Debug.Log("  (No active sources threatening this target)");
                continue;
            }

            foreach (var sourceEntry in targetEntry.Value)
            {
                if (sourceEntry.Key == null)
                {
                    Debug.LogWarning($"    Source: NULL (threat: {sourceEntry.Value:F2}) - will be cleaned up.");
                    continue;
                }
                Debug.Log($"    - From Source: <color=green>{sourceEntry.Key.name}</color>, Threat: {sourceEntry.Value:F2}");
            }
        }
        Debug.Log("------------------------------------");
    }
}


// =====================================================================================
// Example Usage Components (for demonstration purposes)
// =====================================================================================
// These scripts show how to integrate Threat Sources and Threat Targets with the AIThreatSystem.
// =====================================================================================

/// <summary>
/// A simple component to mark a GameObject as a 'Threat Source' and demonstrate
/// how it might generate threat. Attach this to your Player character or other
/// threat-generating entities.
/// </summary>
public class ExampleThreatSource : MonoBehaviour
{
    [Header("Threat Source Settings")]
    [Tooltip("The amount of threat this source generates with each 'attack'.")]
    [SerializeField] private float baseThreatGenerated = 10f;
    [Tooltip("Cooldown between generating threat (e.g., simulating attack speed).")]
    [SerializeField] private float threatCooldown = 1.0f;
    [Tooltip("Radius within which this source will look for targets to threaten.")]
    [SerializeField] private float threatDetectionRadius = 10f;

    private float _lastThreatTime;

    void Update()
    {
        // Example: This ThreatSource (e.g., Player) periodically 'attacks' nearby enemies.
        // In a real game, this would be triggered by actual player input, attack animations, spell casts, etc.
        if (Time.time >= _lastThreatTime + threatCooldown)
        {
            // Find nearby potential 'ThreatTargets' (e.g., enemy AI).
            // For this example, we're looking for GameObjects with the ExampleAI component.
            Collider[] hitColliders = Physics.OverlapSphere(transform.position, threatDetectionRadius);
            
            // Try to find the closest ExampleAI to threaten.
            ExampleAI closestAI = null;
            float closestDistanceSqr = Mathf.Infinity;

            foreach (var hitCollider in hitColliders)
            {
                ExampleAI targetAI = hitCollider.GetComponent<ExampleAI>();
                if (targetAI != null && targetAI.gameObject != this.gameObject) // Ensure it's an AI and not self
                {
                    float distSqr = (targetAI.transform.position - transform.position).sqrMagnitude;
                    if (distSqr < closestDistanceSqr)
                    {
                        closestDistanceSqr = distSqr;
                        closestAI = targetAI;
                    }
                }
            }

            if (closestAI != null)
            {
                // Add threat to the AIThreatSystem for the closest AI.
                AIThreatSystem.Instance.AddThreat(closestAI.gameObject, this.gameObject, baseThreatGenerated);
                Debug.Log($"<color=green>{gameObject.name}</color> generated {baseThreatGenerated:F1} threat against <color=red>{closestAI.gameObject.name}</color>.");
                _lastThreatTime = Time.time; // Reset cooldown after generating threat
            }
        }
    }

    // Optional: Draw the threat detection radius in the editor.
    void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.cyan;
        Gizmos.DrawWireSphere(transform.position, threatDetectionRadius);
    }
}

/// <summary>
/// A simple component to mark a GameObject as an 'AI Threat Target' and demonstrate
/// how it would query the AIThreatSystem to find its highest threat.
/// Attach this to your AI characters.
/// </summary>
[RequireComponent(typeof(Renderer))] // Ensure AI has a renderer for visual feedback
public class ExampleAI : MonoBehaviour
{
    [Header("AI Settings")]
    [Tooltip("How often the AI checks for its highest threat (in seconds).")]
    [SerializeField] private float threatCheckInterval = 0.5f;
    [Tooltip("Color when no threat is present.")]
    [SerializeField] private Color defaultColor = Color.gray;
    [Tooltip("Color when a significant threat is present.")]
    [SerializeField] private Color highThreatColor = Color.red;
    [Tooltip("Threat value at which the AI is fully red (high threat color).")]
    [SerializeField] private float maxThreatForColorScale = 50f;

    private GameObject _currentThreatSource;
    private float _lastThreatCheckTime;
    private Renderer _renderer; // Cached renderer for performance

    // Public property to allow other systems to query who this AI is currently targeting.
    public GameObject CurrentThreatSource => _currentThreatSource;

    private void Awake()
    {
        _renderer = GetComponent<Renderer>();
        _renderer.material.color = defaultColor; // Set initial color
    }

    void Update()
    {
        // Periodically check for the highest threat against this AI.
        if (Time.time >= _lastThreatCheckTime + threatCheckInterval)
        {
            // Query the AIThreatSystem for the current highest threat.
            _currentThreatSource = AIThreatSystem.Instance.GetHighestThreatSource(this.gameObject);
            float highestThreatValue = AIThreatSystem.Instance.GetHighestThreatValue(this.gameObject);

            if (_currentThreatSource != null)
            {
                Debug.Log($"<color=red>{gameObject.name}</color> current highest threat: <color=green>{_currentThreatSource.name}</color> (Value: {highestThreatValue:F2})");
                // In a real game, the AI would now perform actions based on _currentThreatSource.
                // Examples: move towards _currentThreatSource, attack it, cast defensive spells, etc.
                // For demonstration, we'll just change the AI's color based on threat level.
                _renderer.material.color = Color.Lerp(defaultColor, highThreatColor, 
                                            Mathf.Clamp01(highestThreatValue / maxThreatForColorScale));
            }
            else
            {
                // No active threat, AI can revert to default behavior (patrol, idle, etc.).
                Debug.Log($"<color=red>{gameObject.name}</color> has no active threats.");
                _renderer.material.color = defaultColor; // Revert to default color
            }
            _lastThreatCheckTime = Time.time; // Reset threat check timer.
        }
    }
    
    // Optional: Visualizer for Gizmos in Editor to show current target.
    void OnDrawGizmos()
    {
        if (_currentThreatSource != null)
        {
            Gizmos.color = Color.red;
            // Draw a line from this AI to its current highest threat source.
            Gizmos.DrawLine(transform.position, _currentThreatSource.transform.position);
            Gizmos.DrawSphere(transform.position + Vector3.up * 0.5f, 0.2f); // Mark AI's head
            Gizmos.DrawWireSphere(_currentThreatSource.transform.position, 0.5f); // Circle around target
        }
    }

    private void OnDestroy()
    {
        // IMPORTANT: When this AI (target) is destroyed, clear all threats directed at it
        // from the AIThreatSystem to prevent memory leaks and invalid references.
        if (AIThreatSystem.Instance != null)
        {
            AIThreatSystem.Instance.ClearAllThreatsForTarget(this.gameObject);
        }
    }
}

/*
/// =====================================================================================
/// HOW TO USE THIS EXAMPLE IN A UNITY PROJECT:
/// =====================================================================================

1.  **Create the AIThreatSystem Manager:**
    *   Create an Empty GameObject in your scene (e.g., name it "GameManagers").
    *   Attach the `AIThreatSystem.cs` script to this GameObject.
    *   In the Inspector, adjust `Threat Decay Rate Per Second` (how fast threat reduces)
        and `Min Threat Threshold` (minimum threat to be considered active) as desired.
    *   This GameObject (and the system) will persist across scene loads due to `DontDestroyOnLoad`
        if you keep that line in `Awake()`.

2.  **Create a Threat Source (e.g., your Player Character):**
    *   Create a 3D Object (e.g., a Cube or Sphere) in your scene. Name it "Player_ThreatSource".
    *   Attach the `ExampleThreatSource.cs` script to it.
    *   In the Inspector, adjust `Base Threat Generated` (how much threat it adds per 'attack'),
        `Threat Cooldown` (how often it 'attacks'), and `Threat Detection Radius`.
    *   Ensure this GameObject has a `Collider` (e.g., `Box Collider` or `Sphere Collider`)
        to be detected by `Physics.OverlapSphere`.

3.  **Create an AI (Threat Target):**
    *   Create a 3D Object (e.g., a Cube or Sphere) in your scene. Name it "Enemy_AI_1".
    *   Attach the `ExampleAI.cs` script to it.
    *   In the Inspector, adjust `Threat Check Interval` (how often the AI queries the system),
        `Default Color`, `High Threat Color`, and `Max Threat For Color Scale`.
    *   Ensure this GameObject has a `Renderer` (e.g., Mesh Renderer) and a `Collider`.
    *   For `Physics.OverlapSphere` detection, it should also have a `Rigidbody` (set to Kinematic
        if you don't need physics simulation, but need it to act as a solid object for queries).

4.  **Run the Scene:**
    *   Position "Player_ThreatSource" and "Enemy_AI_1" within the `Threat Detection Radius`
        of the player (e.g., 5-10 units apart).
    *   Observe the Console logs:
        *   The "Player_ThreatSource" will periodically log when it generates threat.
        *   The "Enemy_AI_1" will periodically log who its current highest threat is.
    *   Observe the visual feedback:
        *   The "Enemy_AI_1" will change color from its `Default Color` (gray) towards its
            `High Threat Color` (red) as threat accumulates from the player.
        *   A red line and spheres will be drawn in the Scene view (if Gizmos are enabled)
            from the AI to its current highest threat source.
    *   If the "Player_ThreatSource" moves out of range or you disable its `ExampleThreatSource`
        script, the threat will decay. The "Enemy_AI_1" will eventually lose its target
        and revert to its `Default Color`.
    *   If you delete "Enemy_AI_1" from the hierarchy during runtime, its `OnDestroy` method
        will correctly clean up its entries in the `AIThreatSystem`.

/// =====================================================================================
/// INTEGRATING INTO A REAL GAME:
/// =====================================================================================

*   **Threat Generation:**
    *   Instead of the `ExampleThreatSource`'s `Update` loop, you would call
        `AIThreatSystem.Instance.AddThreat(target, source, amount)` from your actual game logic:
        *   **Player Attacks:** When a player's melee attack hits an enemy, a projectile impacts,
            or a spell is cast, pass the `enemy.gameObject`, `player.gameObject`, and the damage/threat amount.
        *   **Healing:** An AI ally healing the player might generate "aggro" (threat) on itself
            from nearby enemies.
        *   **Abilities:** Specific abilities (e.g., a taunt, an area-of-effect spell) can
            add or multiply threat.
        *   **Environment:** Making too much noise, destroying objects, or triggering traps
            could generate threat.
*   **Threat Querying by AI:**
    *   AI agents (like `ExampleAI`) would query `AIThreatSystem.Instance.GetHighestThreatSource(this.gameObject)`
        or `GetHighestThreatValue()` in their decision-making logic:
        *   **Behavior Trees/State Machines:** As a condition or action node (e.g., "CheckForThreat", "TargetHighestThreat").
        *   **AI Update Loops:** Periodically, as shown in `ExampleAI`, to update their current target.
        *   **Event-Driven:** In response to specific game events (e.g., "OnCombatStart").
*   **Cleanup and Edge Cases:**
    *   **OnDestroy:** Always call `AIThreatSystem.Instance.ClearAllThreatsForTarget(this.gameObject)`
        or `ClearAllThreatsFromSource(this.gameObject)` when an entity (AI or player) is destroyed,
        despawns, or otherwise becomes irrelevant, to prevent the threat system from holding
        references to null GameObjects (though the system does have some internal null-checking).
    *   **Player Death/Respawn:** On player death, `ClearAllThreatsFromSource(playerGameObject)`
        might be appropriate. On respawn, the player becomes a new threat source.
    *   **Specific AI behaviors:** An AI might ignore certain threat sources (e.g., friendly fire),
        or prioritize targets based on other factors *in addition* to threat (e.g., closest, lowest health).
        The `GetHighestThreatSource` provides the primary input, but AI logic can layer on top.
*/
```